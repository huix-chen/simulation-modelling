---
title: "simulation"
author: "Huixin Chen"
date: "2023-08-04"
output: word_document
---
Load required library
```{r}
library(tidyr)
library(ggplot2)
```

Variables
```{r}
v_n <- c("H","S","S2","D")  #health states
n_s <- length(v_n) # number of states
n_i <- 45 # number of simulated individuals
v_M_initial <- rep("H", n_i) #assume all individuals are healthy at the beginning
batch_size = 3
start_age=20 
end_age=35
n_t <- end_age - start_age #number of cycles
age <- rep(start_age:end_age)
d_e <- 0.03 #discounting factor
coverage_vec=c(0.5,0.8,1)
```

The Probs function that updates the transition probabilities of every cycle is shown below.
```{r}
Probs <- function(M_it, Treatment, p.HS, p.HD, p.SD, p.SS2, p.S2D) { 
  # M_it:    health state occupied by individual i at cycle t (character variable)

  v.p.it <- rep(NA, n_s)     # create vector of state transition probabilities
  names(v.p.it) <- v_n       # name the vector
  if (Treatment){p.HS=p.SS2=0.1}
  # update v.p.it with the appropriate probabilities   
  v.p.it[M_it == "H"]  <- c(1 - p.HS - p.HD, p.HS, 0, p.HD) # transition probabilities when healthy
  v.p.it[M_it == "S"] <- c(0, 1- p.SD-p.SS2, p.SS2,p.SD)   # transition probabilities when sick
  v.p.it[M_it == "S2"] <- c(0, 0, 1 - p.S2D, p.S2D)   
  v.p.it[M_it == "D"]  <- c(0, 0, 0, 1) # transition probabilities when dead  
  # Normalize probabilities to ensure they sum to 1
  v.p.it <- v.p.it / sum(v.p.it)
  ifelse(sum(v.p.it) == 1, return(v.p.it), print("Probabilities do not sum to 1")) # return the transition probabilities or produce an error
}   
```

utility function
```{r}
Quality <- function (M_it, Treatment, u_H, u_Treatment, u_S, u_S2, u_D,cl = 1) {
  # M_it: health state occupied by individual i at cycle t (character variable)
  # Treatment: take fluoride or not
  # cl:   cycle length (default is 1)
  u.it <- numeric(length(M_it)) 
  # update the utility if healthy
  u.it[M_it == "H"]  <- u_H 
  # update the utility if sick 
  u.it[M_it == "S"] <- Treatment * u_Treatment + (1 - Treatment) * u_S
  #update the utility if sicker
  u.it[M_it == "S2"] <- Treatment * u_Treatment + (1 - Treatment) * u_S2
  u.it[M_it == "D"] <- u_D # update the utility if died
  QALYs <-  u.it * cl            # calculate the QALYs during cycle t
  return(QALYs)                  # return the QALYs
}
```

simulation function
```{r}
cohort_sim <- function(v_M_initial, n_i, n_t, v_n, d_e, coverage_vec, batch_size, end_age, TR.out = TRUE) {
  v_dwe <- 1 / (1 + d_e) ^ (0:n_t)   # calculate the QALY discount weight based on the discount rate d.e
  
  # initialize matrices to capturing the state/utility outcomes for all individuals at each time point 
  m_M <- m_E <- matrix(0, nrow = n_i, ncol = n_t + 1, 
                       dimnames = list(paste("ind", 1:n_i, sep = " "), 
                                       paste("cycle", 0:n_t , sep = " ")))
  m_M[, 1] <- v_M_initial #initial states for all individuals
  results_list <- list()  # create an empty list to store results for different coverage levels
  num_cohorts <- ceiling(n_i / batch_size) #number of cohorts

  # Randomly generate random values for transition probabilities and utilities
  p.HS <- rep(runif(num_cohorts, 0.25, 0.3), each = batch_size)
  p.SS2 <- rep(runif(num_cohorts, 0.15, 0.2), each = batch_size)
  p.HD <- rep(runif(num_cohorts, 0.01, 0.05), each = batch_size)
  p.SD <- rep(runif(num_cohorts, 0.01, 0.05), each = batch_size)
  p.S2D <- rep(runif(num_cohorts, 0.01, 0.05), each = batch_size)
  u_H <- rep(rbeta(num_cohorts, shape1 = 200, shape2 = 3), each = batch_size)
  u_S <- rep(rbeta(num_cohorts, shape1 = 230, shape2 = 230), each = batch_size)
  u_S2 <- rep(rbeta(num_cohorts, shape1 = 230, shape2 = 430), each = batch_size)
  u_Treatment <- rep(rbeta(num_cohorts, shape1 = 130, shape2 = 45), each = batch_size)
  u_D <- 0

  #consider cases when coverage is 50%, 80% and 100%
  for (cov_index in seq_along(coverage_vec)) {
    coverage <- coverage_vec[cov_index]
    cov_results <- list()  # create an empty list to store results for the current coverage level
    
    # Determine the number of individuals receiving treatment based on coverage
    n_treatment <- round(n_i * coverage)
    
    #go through each cohort
    for (cohort in 1:num_cohorts) {
      #find out which individuals are in the same cohort
      start_ind <- (cohort - 1) * batch_size + 1
      end_ind <- min(cohort * batch_size, n_i)
      cohort_age <- age[cohort]
      n_t <- end_age - cohort_age
      
      set.seed(cohort) # Set the seed for reproducibility for each cohort
      
      # Set treatment status for individuals based on coverage
      Treatment_i <- rep(FALSE, n_i)
      Treatment_i[seq_len(n_treatment)] <- TRUE

        ## Simulate the health state trajectories and QALYs for the current cohort of individuals
        for (i in start_ind:end_ind) {
          for (t in 1:n_t) {
            p.HS.cohort <- p.HS[cohort + t - 1]
            p.SS2.cohort <- p.SS2[cohort + t - 1]
            p.HD.cohort <- p.HD[cohort + t - 1]
            p.SD.cohort <- p.SD[cohort + t - 1]
            p.S2D.cohort <- p.S2D[cohort + t - 1]
            u_H.cohort <- u_H[cohort + t - 1]
            u_S.cohort <- u_S[cohort + t - 1]
            u_S2.cohort <- u_S2[cohort + t - 1]
            u_Treatment.cohort <- u_Treatment[cohort + t - 1]
          
            v_p <- Probs(m_M[i, t], Treatment_i[i], p.HS.cohort, p.HD.cohort, 
                         p.SD.cohort, p.SS2.cohort, p.S2D.cohort)
            m_E[i, 1] <- Quality(v_M_initial[i], Treatment_i[i], u_H.cohort, 
                                 u_Treatment.cohort, u_S.cohort, u_S2.cohort, u_D)
            m_M[i, t + 1] <- sample(v_n, prob = v_p, size = 1)
            m_E[i, t + 1] <- Quality(m_M[i, t + 1], Treatment_i[i], u_H.cohort, 
                                     u_Treatment.cohort, u_S.cohort, u_S2.cohort, u_D)

          }

          # Update m_M[i, t + 1] after the inner loop is completed for this individual
          m_M[i, t + 1] <- m_M[i, t + 1]
        }
      }
      
    
    te <- rowSums(m_E * v_dwe)  # Calculate total (discounted) QALYs for the individual
    
    # Create a trace from the cohort trajectories
    if (TR.out == TRUE) {
      TR <- t(apply(m_M, 2, function(x) table(factor(x, levels = v_n, ordered = TRUE))))
      TR <- TR / n_i # Create a distribution trace
      rownames(TR) <- paste("Cycle", 0:15, sep = " ")     # Name the rows 
      colnames(TR) <- v_n                                  # Name the columns 
    } else {
      TR <- NULL
    }
    
    te_hat <- mean(te)
    
    cov_results$m_M <- m_M  # Store the matrix of health states for the current coverage level
    cov_results$m_E <- m_E  # Store the matrix of QALYs for the current coverage level
    cov_results$te <- te    # Store the total (discounted) QALYs for the current coverage level
    cov_results$te_hat <- te_hat  # Store the average (discounted) QALYs for the current coverage level
    cov_results$TR <- TR    # Store the trace for the current coverage level
    
    results_list[[cov_index]] <- cov_results  # Store the results for the current coverage level in the results list
  }
  
  return(results_list)  # Return the list of results for different coverage levels
}
```

Run the simulation function
```{r}
result=cohort_sim(v_M_initial, n_i, n_t, v_n, d_e, coverage_vec, batch_size, end_age) 
```


Modified plot_trace function to accept 'result' as an argument
```{r}
plot_trace <- function(result, v_n, n_t) {
  df_M <- data.frame(Cycle = 0:n_t, result[[1]]$TR, check.names = FALSE)
  df_M_long <- tidyr::gather(df_M, key = "Health State", value, 2:ncol(df_M))
  df_M_long$`Health State` <- factor(df_M_long$`Health State`, levels = v_n)
  gg_trace <- ggplot(df_M_long, aes(x = Cycle, y = value, color = `Health State`, linetype = `Health State`)) +
    geom_line(size = 1) +
    xlab("Cycle") +
    ylab("Proportion") +
    scale_x_continuous(breaks = scales::pretty_breaks(n = 8)) +
    theme_bw(base_size = 14) +
    theme(legend.position = "bottom", legend.background = element_rect(fill = NA))
  return(gg_trace)
}
```

plot trace plot for all cohorts
```{r}
plot_trace(result, v_n,n_t)
```

trace the health state for each individual
```{r}
df_M <- data.frame(Cycle = 0:(length(result[[1]]$m_M["ind 1",]) - 1), `Health State` = result[[1]]$m_M["ind 1",])


# Define the desired order of Health State levels
desired_order <- c("D", "S2", "S","H")

# Reorder the Health State column in the data frame using the desired order
df_M$Health.State <- factor(df_M$Health.State, levels = desired_order)

# Create the scatter plot
ggplot(df_M, aes(x = Cycle, y = Health.State)) +
  geom_point(size = 3) +
  xlab("Cycle") +
  ylab("Health State") +
  theme_bw(base_size = 14)
```

```{r}
calculate_dmft_scores <- function(health_state_matrix) {
  mapping <- c(S = 2, S2 = 3)
  
  dmft_scores <- numeric(nrow(health_state_matrix))
  
  for (i in 1:nrow(health_state_matrix)) {
    dmft_scores[i] <- sum(mapping[health_state_matrix[i,]], na.rm = TRUE)
  }
  
  return(dmft_scores)
}


DMFT_50coverage <- calculate_dmft_scores(result[[1]]$m_M)
DMFT_80coverage <- calculate_dmft_scores(result[[2]]$m_M)
DMFT_100coverage <- calculate_dmft_scores(result[[3]]$m_M)


```




```{r}
assign_DMFT_score <- function(m_M, v_n, n_bootstraps = 1000) {
  # Create a matrix to store the DMFT scores for each individual at each cycle
  m_DMFT <- matrix(nrow = nrow(m_M), ncol = ncol(m_M))
  
  # Assign DMFT scores based on the health state in each cycle for each individual
  for (i in 1:nrow(m_M)) {
    for (t in 1:ncol(m_M)) {
      state <- m_M[i, t]
      # Individual is healthy
      if (state == v_n[1]) {
        m_DMFT[i, t] <- 0
      } else if (state == v_n[length(v_n)]) {
        # Individual is dead
        m_DMFT[i, t] <- NA
      } else if (state == v_n[length(v_n) - 2]) {
        # Individual is in a sick state
          m_DMFT[i, t] <- 2
        } else if (state == v_n[length(v_n) - 1]) {
          # Individual is in the sicker state
          m_DMFT[i, t] <- 4
        }
    }
  }
  
  # Calculate the DMFT scores for each individual at the last cycle
  last_cycle_DMFT <- m_DMFT[, ncol(m_DMFT)]
  
  # Bootstrap procedure to calculate confidence intervals for the DMFT scores at the last cycle
  bootstrap_results <- replicate(n_bootstraps, sample(last_cycle_DMFT, replace = TRUE))
  
  # Calculate the desired percentile-based confidence intervals (e.g., 95% confidence interval)
  confidence_intervals <- quantile(bootstrap_results, c(0.025, 0.975))
  
  # Return the matrix of DMFT scores for each individual at each cycle,
  # the DMFT scores at the last cycle, and the confidence intervals
  return(list(All_DMFT_Scores = m_DMFT, Last_Cycle_DMFT = last_cycle_DMFT, Confidence_Intervals = confidence_intervals))
}
```

```{r}
# Create an empty list to store the results
all_results <- list()

# Loop through the matrices and apply assign_DMFT_score function to each of them
for (i in 1:length(coverage_vec)) {
  current_result <- assign_DMFT_score(result[[i]]$m_M, v_n)
  all_results[[i]] <- current_result
}

all_results
```

```{r}
# Initialize an empty vector to store all the confidence intervals
all_confidence_intervals <- c()

# Iterate over the all_results list
for (i in 1:length(coverage_vec)) {
  dmft_CI <- all_results[[i]]$Confidence_Intervals
  all_confidence_intervals <- c(all_confidence_intervals, dmft_CI)
}

# Create a data frame with coverage values and confidence intervals
plot_data <- data.frame(
  Coverage = coverage_vec,
  Lower = sapply(all_results, function(result) result$Confidence_Intervals[1]),
  Upper = sapply(all_results, function(result) result$Confidence_Intervals[2])
)

# Create the plot
ggplot(plot_data, aes(x = Coverage)) +
  geom_vline(aes(xintercept = Coverage), linetype = "dashed", color = "gray70") +  # Vertical lines for coverage values
  geom_errorbar(aes(ymin = Lower, ymax = Upper), width = 0.1) +  # Confidence interval bars
  labs(
    x = "Coverage Value",
    y = "Confidence Interval",
    title = "Confidence Intervals for Different Coverage Values"
  )

```


